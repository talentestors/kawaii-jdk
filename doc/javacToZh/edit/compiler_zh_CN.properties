#
# Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
# are preceded by a stylized comment describing the type of the corresponding
# values.
# The types currently in use are
#
# boolean           true or false
# file name         the name of an input file; e.g.   MyFile.java
# message segment   a sub-message; see compiler.misc.*
# modifier          a Java modifier; e.g. public, private, protected
# name              a name, typically a Java identifier
# number            an integer
# option name       the name of a command line option
# source version    a source version number, such as 1.5, 1.6, 1.7
# string            a general string
# symbol            the name of a declared type
# symbol kind       a description of the kind of a declaration; see compiler.misc.kindname.*
# token             the name of a non-terminal in source code; see compiler.misc.token.*
# type              a Java type; e.g. int, X, X<T>
# unused            the value is not used in this message
#
# list of X         a comma-separated list of items; e.g. list of type
# X or Y            alternation; e.g. message segment or type
# set of X          a comma-separated collection of items; e.g. set of modifier
#
# These may be composed: e.g.   list of type or message segment
#
# These comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
# using info derived from the collected set of examples in test/tools/javac/diags/examples.
# MessageInfo can also be run as a standalone utility providing more facilities
# for manipulating this file. For more details, see MessageInfo.java.

##
## errors
##

# 0: symbol
compiler.err.abstract.cant.be.instantiated={0}是抽象的; 无法实例化

compiler.err.abstract.meth.cant.have.body=抽象方法不能有主体

compiler.err.already.annotated={0} {1}已进行注释

# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol
compiler.err.already.defined=已在{2} {3}中定义了{0} {1}

# 0: symbol kind, 1: symbol, 2: symbol kind, 3: symbol kind, 4: symbol
compiler.err.already.defined.in.clinit=已在{3} {4}的{2}中定义了{0} {1}

# 0: string
compiler.err.already.defined.single.import={0}的 single-type-import 已定义具有相同简名的类型

# 0: string
compiler.err.already.defined.static.single.import={0}的静态 single-type-import 已定义具有相同简名的类型

compiler.err.already.defined.this.unit=已在该编译单元中定义{0}

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value=对于元素 ''{1}'', 注释 @{0} 缺少默认值

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value.1=对于元素{1}, 注释 @{0} 缺少默认值

# 0: type
compiler.err.annotation.not.valid.for.type=注释对于类型{0}的元素无效

compiler.err.annotation.type.not.applicable=注释类型不适用于该类型的声明

compiler.err.annotation.value.must.be.annotation=注释值必须为注释

compiler.err.annotation.value.must.be.class.literal=注释值必须为类文字

compiler.err.annotation.value.must.be.name.value=注释值必须采用 ''name=value'' 格式

compiler.err.annotation.value.not.allowable.type=注释值不是允许的类型

compiler.err.anon.class.impl.intf.no.args=匿名类实现接口; 不能有参数

compiler.err.anon.class.impl.intf.no.typeargs=匿名类实现接口; 不能具有类型参数

compiler.err.anon.class.impl.intf.no.qual.for.new=匿名类实现接口; 不能有限定符 - 对于新

compiler.err.cant.inherit.from.anon=无法从匿名类继承

# 0: symbol, 1: symbol, 2: symbol
compiler.err.array.and.varargs=无法在{2}中同时声明{0}和{1}

compiler.err.array.dimension.missing=缺少数组维

# 0: type
compiler.err.array.req.but.found=需要数组, 但找到{0}

compiler.err.attribute.value.must.be.constant=元素值必须为常量表达式

# 0: statement type
compiler.err.bad.initializer={0}的初始化程序错误

compiler.err.break.outside.switch.loop=在 switch 或 loop 外部中断

# 0: name
compiler.err.call.must.be.first.stmt.in.ctor=对{0}的调用必须是构造器中的第一个语句

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.err.cant.apply.symbol=无法将{4} {5}中的{0} {1}应用到给定类型;\n需要: {2}\n找到: {3}\n原因: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.err.cant.apply.symbols=对于{1}({2}), 找不到合适的{0}

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.misc.cant.apply.symbol=无法将 {4} {5}中的 {0} {1}应用到给定类型\n需要: {2}\n找到: {3}\n原因: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.misc.cant.apply.symbols=对于{1}({2}), 找不到合适的{0}

# 0: symbol kind, 1: symbol
compiler.misc.no.abstracts=在 {0} {1} 中找不到抽象方法

# 0: symbol kind, 1: symbol
compiler.misc.incompatible.abstracts=在 {0} {1} 中找到多个非覆盖抽象方法

compiler.err.bad.functional.intf.anno=意外的 @FunctionalInterface 注释

# 0: message segment
compiler.err.bad.functional.intf.anno.1=意外的 @FunctionalInterface 注释\n{0}

# 0: symbol
compiler.misc.not.a.functional.intf={0} 不是函数接口，这里不可以哦~

# 0: symbol, 1: message segment
compiler.misc.not.a.functional.intf.1={0} 不是函数接口，这里不可以哦~\n{1}

# 0: symbol, 1: symbol kind, 2: symbol
compiler.misc.invalid.generic.lambda.target=lambda 表达式的函数描述符无效\n{1} {2} 中的方法 {0} 为泛型方法

# 0: symbol kind, 1: symbol
compiler.misc.incompatible.descs.in.functional.intf=在 {0} {1} 中找到不兼容的函数描述符

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor=描述符: {2} {0}({1})

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor.throws=描述符: {2} {0}({1}) 抛出{3}

# 0: type
compiler.misc.no.suitable.functional.intf.inst=无法推断{0}的函数接口描述符

# 0: message segment
compiler.misc.bad.intersection.target.for.functional.expr=lambda 或方法引用的交叉类型目标错误\n{0}

# 0: symbol or type
compiler.misc.not.an.intf.component=组件类型{0}不是接口

# 0: symbol kind, 1: message segment
compiler.err.invalid.mref={0}引用无效\n{1}

# 0: symbol kind, 1: message segment
compiler.misc.invalid.mref={0}引用无效\n{1}

compiler.misc.static.mref.with.targs=有关静态方法引用的参数化限定符

compiler.misc.static.bound.mref=静态限制范围方法引用

# 0: symbol
compiler.err.cant.assign.val.to.final.var=无法为最终变量{0}分配值

# 0: symbol, 1: message segment
compiler.err.cant.ref.non.effectively.final.var=从{1}引用的本地变量必须是最终变量或实际上的最终变量


compiler.misc.lambda=lambda 表达式

compiler.misc.inner.cls=内部类

# 0: type
compiler.err.cant.deref=无法取消引用{0}

compiler.err.cant.extend.intf.annotation=对于 @interfaces, 不允许 ''extends''

# 0: symbol
compiler.err.cant.inherit.from.final=无法从最终{0}进行继承

# 0: symbol
compiler.err.cant.ref.before.ctor.called=无法在调用超类型构造器之前引用{0}

compiler.err.cant.select.static.class.from.param.type=无法从参数化的类型中选择静态类

# 0: symbol, 1: string, 2: string
compiler.err.cant.inherit.diff.arg=无法使用以下不同的参数继承{0}: <{1}> 和 <{2}>

compiler.err.catch.without.try=有 ''catch'', 但是没有 ''try''

# 0: symbol kind, 1: symbol
compiler.err.clash.with.pkg.of.same.name={0} {1}与带有相同名称的程序包冲突

compiler.err.class.not.allowed=此处不允许使用类, 接口或枚举声明

compiler.err.const.expr.req=需要常量表达式

compiler.err.cont.outside.loop=continue 到外面去了！

# 0: symbol
compiler.err.cyclic.inheritance=涉及{0}的循环继承

# 0: symbol
compiler.err.cyclic.annotation.element=元素 {0} 的类型为循环

# 0: unused
compiler.err.call.to.super.not.allowed.in.enum.ctor=在枚举构造器中不允许调用超类

# 0: type
compiler.err.no.superclass={0}不具有超类。

# 0: symbol, 1: type, 2: symbol, 3: type, 4: unused
compiler.err.concrete.inheritance.conflict={1}中的方法{0}和{3}中的方法{2}是使用相同的签名继承的

compiler.err.default.allowed.in.intf.annotation.member=注释类型声明中仅允许默认值

# 0: symbol
compiler.err.doesnt.exist=程序包{0}不存在

# 0: type
compiler.err.duplicate.annotation.invalid.repeated=注释{0}不是有效的可重复注释

# 0: name, 1: type
compiler.err.duplicate.annotation.member.value=注释@{1}中的元素 ''{0}'' 重复。

# 0: name, 1: unused
compiler.err.duplicate.annotation.missing.container={0} 不是可重复的注释类型

# 0: type, 1: unused
compiler.err.invalid.repeatable.annotation=注释重复: 使用无效的 @Repeatable 注释对{0}进行了注释

# 0: symbol or type
compiler.err.invalid.repeatable.annotation.no.value={0}不是有效的 @Repeatable, 未声明任何值元素方法

# 0: type, 1: number
compiler.err.invalid.repeatable.annotation.multiple.values={0}不是有效的 @Repeatable, 已声明 {1} 个名为 ''value'' 的元素方法

# 0: type
compiler.err.invalid.repeatable.annotation.invalid.value={0}不是有效的 @Repeatable: 值元素无效

# 0: symbol type, 1: unused, 2: type
compiler.err.invalid.repeatable.annotation.value.return=包含注释类型 ({0}) 必须声明类型{2}的名为 ''value'' 的元素

# 0: symbol or type, 1: symbol
compiler.err.invalid.repeatable.annotation.elem.nondefault=对于元素 {1}, 包含注释类型 ({0}) 没有默认值

# 0: symbol, 1: unused, 2: symbol, 3: unused
compiler.err.invalid.repeatable.annotation.retention=包含注释类型 ({0}) 的保留期短于可重复注释类型 ({2}) 的保留期

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.documented=可重复注释类型 ({1}) 是 @Documented, 而包含注释类型 ({0}) 则不是

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.inherited=可重复注释类型 ({1}) 是 @Inherited, 而包含注释类型 ({0}) 则不是

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.incompatible.target=包含注释类型 ({0}) 适用的目标多于可重复注释类型 ({1})

# 0: symbol
compiler.err.invalid.repeatable.annotation.repeated.and.container.present=容器 {0} 不得与其包含的元素同时存在

# 0: name
compiler.err.duplicate.class=类重复: {0}

compiler.err.duplicate.case.label=case 标签重复

compiler.err.duplicate.default.label=default 标签重复

compiler.err.else.without.if=有 ''if'', 但是没有 ''else''

compiler.err.empty.char.lit=空字符文字

# 0: symbol
compiler.err.encl.class.required=需要包含{0}的封闭实例

compiler.err.enum.annotation.must.be.enum.constant=枚举注释值必须是枚举常量

compiler.err.enum.cant.be.instantiated=无法实例化枚举类型

compiler.err.enum.label.must.be.unqualified.enum=枚举 switch case 标签必须为枚举常量的非限定名称

compiler.err.enum.no.subclassing=类无法直接扩展 java.lang.Enum

compiler.err.enum.types.not.extensible=枚举类型不可继承

compiler.err.enum.no.finalize=枚举不能有 finalize 方法

# 0: file name, 1: string
compiler.err.error.reading.file=读取{0}时出错; {1}

# 0: type
compiler.err.except.already.caught=已捕获到异常错误{0}

# 0: type
compiler.err.except.never.thrown.in.try=在相应的 try 语句主体中不能抛出异常错误{0}

# 0: symbol
compiler.err.final.parameter.may.not.be.assigned=不能分配最终参数{0}

# 0: symbol
compiler.err.try.resource.may.not.be.assigned=可能未分配可自动关闭的资源{0}

# 0: symbol
compiler.err.multicatch.parameter.may.not.be.assigned=可能未分配 multi-catch 参数{0}

# 0: type, 1: type
compiler.err.multicatch.types.must.be.disjoint=multi-catch 语句中的替代无法通过子类化关联\n替代{0}是替代{1}的子类

compiler.err.finally.without.try=有 ''finally'', 但是没有 ''try''

# 0: type, 1: message segment
compiler.err.foreach.not.applicable.to.type=for-each 不适用于表达式类型\n要求: {1}\n找到:    {0}

compiler.err.fp.number.too.large=不行太大了！！！

compiler.err.fp.number.too.small=是花生米吧！

compiler.err.generic.array.creation=创建泛型数组

compiler.err.generic.throwable=泛型类不能扩展 java.lang.Throwable

# 0: symbol
compiler.err.icls.cant.have.static.decl=内部类{0}中的静态声明非法\n修饰符 ''static'' 仅允许在常量变量声明中使用

# 0: string
compiler.err.illegal.char=非法字符: ''{0}''

compiler.err.illegal.char.for.encoding=编码{0}的不可映射字符

# 0: set of modifier, 1: set of modifier
compiler.err.illegal.combination.of.modifiers=非法的修饰符组合: {0}和{1}

compiler.err.illegal.enum.static.ref=初始化程序中对静态字段的引用不合法

compiler.err.illegal.esc.char=非法转义符

compiler.err.illegal.forward.ref=非法前向引用

# 0: symbol, 1: string
compiler.err.not.in.profile={0}在配置文件 ''{1}'' 中不可用

# 0: symbol
compiler.warn.forward.ref=先引用变量 ''{0}'', 然后再对其初始化

compiler.err.illegal.self.ref=初始化程序中存在自引用

# 0: symbol
compiler.warn.self.ref=变量 ''{0}'' 的初始化程序中存在自引用

compiler.err.illegal.generic.type.for.instof=instanceof 的泛型类型不合法

# 0: type
compiler.err.illegal.initializer.for.type={0}的初始化程序不合法

compiler.err.illegal.line.end.in.char.lit=字符文字的行结尾不合法

compiler.err.illegal.nonascii.digit=非法的非 ASCII 数字

compiler.err.illegal.underscore=非法下划线

compiler.err.illegal.dot=非法 ''.''

# 0: symbol
compiler.err.illegal.qual.not.icls=非法限定符; {0}不是内部类

compiler.err.illegal.start.of.expr=非法的表达式开始

compiler.err.illegal.start.of.stmt=非法的语句开始

compiler.err.illegal.start.of.type=非法的类型开始

compiler.err.illegal.unicode.esc=非法的 Unicode 转义

# 0: symbol
compiler.err.import.requires.canonical=导入需要{0}的规范名称

compiler.err.improperly.formed.type.param.missing=类型的格式不正确, 缺少某些参数

compiler.err.improperly.formed.type.inner.raw.param=类型的格式不正确, 给出了原始类型的类型参数

# 0: type, 1: type
compiler.err.incomparable.types=不可比较的类型: {0}和{1}

# 0: number
compiler.err.int.number.too.large=过大的整数: {0}

compiler.err.intf.annotation.members.cant.have.params=注释类型声明中的元素无法声明形参

# 0: symbol
compiler.err.intf.annotation.cant.have.type.params=注释类型 {0} 不能为泛型

compiler.err.intf.annotation.members.cant.have.type.params=注释类型声明中的元素不能为泛型方法

# 0: symbol, 1: type
compiler.err.intf.annotation.member.clash=注释类型{1}声明与方法 {0} 同名的元素

compiler.err.intf.expected.here=此处需要接口

compiler.err.intf.meth.cant.have.body=接口抽象方法不能带有主体

# 0: symbol
compiler.err.invalid.annotation.member.type=注释类型元素 {0} 的类型无效

compiler.err.invalid.binary.number=二进制数字中必须包含至少一个二进制数

compiler.err.invalid.hex.number=十六进制数字必须包含至少一位十六进制数

compiler.err.invalid.meth.decl.ret.type.req=方法声明无效; 需要返回类型

compiler.err.varargs.and.old.array.syntax=variable-arity 参数中不允许使用传统数组记号

compiler.err.varargs.and.receiver =接收方参数不允许使用 varargs 记号

compiler.err.array.and.receiver =接收方参数不允许使用传统数组记号

compiler.err.variable.not.allowed=此处不允许使用变量声明

# 0: name
compiler.err.label.already.in.use=标签{0}已使用

# 0: symbol
compiler.err.local.var.accessed.from.icls.needs.final=从内部类中访问本地变量{0}; 需要被声明为最终类型

compiler.err.local.enum=枚举类型不能为本地类型

compiler.err.cannot.create.array.with.type.arguments=无法创建具有类型变量的数组

compiler.err.cannot.create.array.with.diamond=无法创建具有 ''<>'' 的数组

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=代码过长

compiler.err.limit.code.too.large.for.try.stmt=try 语句的代码过长

compiler.err.limit.dimensions=数组类型维过多

compiler.err.limit.locals=太多了！呜呜呜~

compiler.err.limit.parameters=参数过多

compiler.err.limit.pool=常量太多了！呜呜呜~

compiler.err.limit.pool.in.class=类{0}中的常量过多

compiler.err.limit.stack=代码需要过多太多了！呜呜呜~

compiler.err.limit.string=常量字符串过长

compiler.err.limit.string.overflow=对于常量池来说, 字符串 "{0}..." 的 UTF8 表示过长

compiler.err.malformed.fp.lit=浮点文字的格式错误

compiler.err.method.does.not.override.superclass=方法不会覆盖或实现超类型的方法

compiler.err.missing.meth.body.or.decl.abstract=缺少方法主体, 或声明抽象

compiler.err.missing.ret.stmt=应该返回什么呢？

# 0: unused
compiler.misc.missing.ret.val=应该返回什么呢？

compiler.misc.unexpected.ret.val=应该返回什么呢？

# 0: set of modifier
compiler.err.mod.not.allowed.here=此处不允许使用修饰符{0}

compiler.err.intf.not.allowed.here=此处不允许使用接口

compiler.err.enums.must.be.static=只有在静态上下文中才允许使用枚举声明

# 0: symbol, 1: symbol
compiler.err.name.clash.same.erasure=名称冲突: {0}和{1}具有相同疑符

# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: unused, 5: unused
compiler.err.name.clash.same.erasure.no.override=名称冲突: {1}中的{0}和{3}中的{2}具有相同疑符, 但两者均不覆盖对方

# 0: symbol, 1: symbol, 2: symbol, 3: symbol, 4: symbol, 5: symbol
compiler.err.name.clash.same.erasure.no.override.1=名称冲突: {1} 中的 {0} 覆盖的方法的疑符与另一个方法的相同, 但两者均不覆盖对方\n第一个方法:  {3} 中的 {2}\n第二个方法: {5} 中的 {4}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.err.name.clash.same.erasure.no.hide=名称冲突: {1} 中的 {0} 和 {3} 中的 {2} 具有相同疑符, 但两者均不隐藏对方

compiler.err.name.reserved.for.internal.use={0}为内部使用保留

compiler.err.native.meth.cant.have.body=本机方法不能带有主体

# 0: type, 1: type
compiler.err.neither.conditional.subtype=? 的不兼容类型: 两者都不是对方的子类型\n第二个操作数: {0}\n第三个操作数: {1}

# 0: message segment
compiler.misc.incompatible.type.in.conditional=条件表达式中的类型错误\n{0}

compiler.misc.conditional.target.cant.be.void=条件表达式的目标类型不能为空

# 0: type
compiler.misc.incompatible.ret.type.in.lambda=lambda 表达式中的返回类型错误\n{0}

# 0: type
compiler.misc.incompatible.ret.type.in.mref=方法引用中的返回类型错误\n{0}

compiler.err.lambda.body.neither.value.nor.void.compatible=lambda 主体不是值, 也不与 void 兼容

# 0: list of type
compiler.err.incompatible.thrown.types.in.mref=方法引用中抛出的类型{0}不兼容

compiler.misc.incompatible.arg.types.in.lambda=lambda 表达式中的参数类型不兼容

compiler.misc.incompatible.arg.types.in.mref=方法引用中的参数类型不兼容

compiler.err.new.not.allowed.in.annotation=注释中不允许使用 ''new''

compiler.err.no.annotation.member={1}中没有注释成员{0}

compiler.err.no.encl.instance.of.type.in.scope=作用域中没有类型为{0}的封闭实例

compiler.err.no.intf.expected.here=此处不需要接口

compiler.err.no.match.entry={0}在{1}的条目中没有匹配项; 需要{2}

compiler.err.not.annotation.type={0}不是注释类型

# 0: symbol, 1: symbol
compiler.err.not.def.access.class.intf.cant.access={1}中的{0}是在不可访问的类或接口中定义的

# 0: symbol, 1: symbol
compiler.misc.not.def.access.class.intf.cant.access={1}中的{0}是在不可访问的类或接口中定义的

# 0: symbol, 1: list of type, 2: type
compiler.misc.cant.access.inner.cls.constr=无法访问构造器 {0}({1})\n作用域中没有类型为{2}的封闭实例

# 0: symbol, 1: symbol
compiler.err.not.def.public.cant.access={0}在{1}中不是公共的; 无法从外部程序包中对其进行访问

# 0: symbol, 1: symbol
compiler.misc.not.def.public.cant.access={0}在{1}中不是公共的; 无法从外部程序包中对其进行访问

# 0: name
compiler.err.not.loop.label=不是 loop 标签: {0}

compiler.err.not.stmt=不是语句(*≧ω≤)

# 0: symbol
compiler.err.not.encl.class=(*≧ω≤)不是封闭类: {0}

# 0: name, 1: type, 2: unused
compiler.err.operator.cant.be.applied=一元运算符 ''{0}'' 的操作数类型{1}错误

# 0: name, 1: type, 2: type
compiler.err.operator.cant.be.applied.1=二元运算符 ''{0}'' 的操作数类型错误\n第一个类型:  {1}\n第二个类型: {2}

compiler.err.pkg.annotations.sb.in.package-info.java=程序包注释应在文件 package-info.java 中

# 0: symbol
compiler.err.pkg.clashes.with.class.of.same.name=程序包{0}与带有相同名称的类冲突

compiler.err.warnings.and.werror=发现杂鱼~ -Werror

# Errors related to annotation processing

# 0: symbol, 1: string, 2: stack-trace
compiler.err.proc.cant.access=无法访问{0}\n{1}\n有关详细信息, 请参阅以下堆栈跟踪。\n{2}

# 0: symbol, 1: string
compiler.err.proc.cant.access.1=无法访问{0}\n{1}

# 0: string
compiler.err.proc.cant.find.class=找不到 ''{0}'' 的类文件。

# Print a client-generated error message; assumed to be localized, no translation required
# 0: string
compiler.err.proc.messager={0}

# 0: list of string
compiler.err.proc.no.explicit.annotation.processing.requested=仅当显式请求注释处理时才接受类名称 ''{0}''

compiler.err.proc.no.service=ServiceLoader 不可用, 但它是注释处理所必需的。

compiler.err.proc.processor.bad.option.name=处理程序 ''{1}'' 提供的选项名称 ''{0}'' 错误

# 0: string
compiler.err.proc.processor.cant.instantiate=无法实例化处理程序 ''{0}'' 的实例

# 0: string
compiler.err.proc.processor.not.found=找不到注释处理程序 ''{0}''

# 0: string
compiler.err.proc.processor.wrong.type=注释处理程序 ''{0}'' 未实现 javax.annotation.processing.Processor

compiler.err.proc.service.problem=创建服务加载器以加载处理程序时出错。

compiler.err.proc.bad.config.file=服务配置文件不正确, 或构造处理程序对象{0}时抛出异常错误

compiler.err.proc.cant.create.loader=无法为注释处理程序{0}创建类加载器

# 0: unused
compiler.err.qualified.new.of.static.class=限定的新静态类

compiler.err.recursive.ctor.invocation=递归构造器调用

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.err.ref.ambiguous=对{0}的引用不明确\n{3} 中的{1} {2} 和 {6} 中的{4} {5} 都匹配

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.misc.ref.ambiguous=对{0}的引用不明确\n{3} 中的{1} {2} 和 {6} 中的{4} {5} 都匹配

compiler.err.repeated.annotation.target=注释目标重复

compiler.err.repeated.interface=接口重复

compiler.err.repeated.modifier=修饰符重复

# 0: symbol, 1: set of modifier, 2: symbol
compiler.err.report.access={0} 在 {2} 中是 {1} 访问控制

# 0: symbol, 1: set of modifier, 2: symbol
compiler.misc.report.access={0} 在 {2} 中是 {1} 访问控制

compiler.err.ret.outside.meth=返回外部方法

compiler.err.signature.doesnt.match.supertype=签名与{0}不匹配; 不兼容的超类型

compiler.err.signature.doesnt.match.intf=签名与{0}不匹配; 不兼容的接口

# 0: number, 1: number
compiler.err.method.invoked.with.incorrect.number.arguments=使用不正确数量的参数调用了方法; 预期为 {0} 个, 找到 {1} 个

# 0: symbol, 1: symbol, 2: symbol
compiler.err.does.not.override.abstract={0}不是抽象的, 并且未覆盖{2}中的抽象方法{1}

compiler.err.source.cant.overwrite.input.file=写入源时出错; 无法覆盖输入文件{0}

compiler.err.stack.sim.error=内部错误: {0}中的太多了！呜呜呜~ sim 错误

compiler.err.static.imp.only.classes.and.interfaces=仅从类和接口静态导入

compiler.err.string.const.req=需要常量字符串表达式

# 0: symbol, 1: symbol
compiler.err.synthetic.name.conflict=符号{0}与{1}中的 compiler-synthesized 符号冲突

# 0: symbol, 1: symbol
compiler.warn.synthetic.name.conflict=符号{0}与{1}中的 compiler-synthesized 符号冲突

compiler.err.throws.not.allowed.in.intf.annotation=@interface 成员中不允许使用 throws 子句

compiler.err.try.without.catch.or.finally=有 ''try'', 但是没有 ''catch'' 或 ''finally''

compiler.err.try.without.catch.finally.or.resource.decls=''try'' 不带有 ''catch'', ''finally'' 或资源声明

# 0: symbol
compiler.err.type.doesnt.take.params=类型{0}不带有参数

compiler.err.type.var.cant.be.deref=无法从类型变量中进行选择

compiler.err.type.var.may.not.be.followed.by.other.bounds=类型变量后面不能带有其他限制范围

compiler.err.type.var.more.than.once=类型变量{0}在{1}的结果类型中多次出现; 必须对其进行实例化

compiler.err.type.var.more.than.once.in.result=类型变量{0}在{1}的类型中多次出现; 必须对其进行实例化

# 0: type, 1: type, 2: string
compiler.err.types.incompatible.diff.ret=类型{0}和{1}不兼容; 两者都定义了{2}, 但却带有不相关的返回类型

# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.err.types.incompatible.unrelated.defaults={0} {1}从类型 {4} 和 {5} 中继承了{2}({3}) 的不相关默认值

# 0: kind, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.err.types.incompatible.abstract.default={0} {1}从类型 {4} 和 {5} 中继承了{2}({3}) 的抽象和默认值

# 0: name, 1: kind, 2: symbol
compiler.err.default.overrides.object.member={1} {2} 中的默认方法{0}覆盖了 java.lang.Object 的成员

# 0: type
compiler.err.illegal.static.intf.meth.call=静态接口方法调用非法\n应将接收方表达式替换为类型限定符 ''{0}''

# 0: type, 1: message segment
compiler.err.illegal.default.super.call=默认超级调用中的类型限定符{0}错误\n{1}

# 0: symbol, 1: type
compiler.misc.overridden.default=覆盖了{1}中的方法 {0}

# 0: symbol, 1: type or symbol
compiler.misc.redundant.supertype=冗余接口 {0} 已由 {1} 扩展

compiler.err.unclosed.char.lit=未结束的字符文字

compiler.err.unclosed.comment=未结束的注释

compiler.err.unclosed.str.lit=未结束的字符串文字

# 0: name
compiler.err.unsupported.encoding=不支持的编码: {0}

compiler.err.io.exception=读取源文件时出错: {0}

# 0: name
compiler.err.undef.label=未定义的标签: {0}

# 0: message segment, 1: unused
compiler.err.cant.apply.diamond=无法推断{0}的类型参数

# 0: message segment or type, 1: message segment
compiler.err.cant.apply.diamond.1=无法推断{0}的类型参数\n原因: {1}

# 0: message segment or type, 1: message segment
compiler.misc.cant.apply.diamond.1=无法推断{0}的类型参数\n原因: {1}

compiler.err.unreachable.stmt=无法访问的语句

compiler.err.initializer.must.be.able.to.complete.normally=初始化程序必须能够正常完成

# 0: type
compiler.err.unreported.exception.need.to.catch.or.throw=未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出

# 0: type
compiler.err.unreported.exception.default.constructor=默认构造器中未报告的异常错误{0}

# 0: type, 1: name
compiler.err.unreported.exception.implicit.close=未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出\n对资源变量 ''{1}'' 隐式调用 close() 时抛出了异常错误

compiler.err.unsupported.cross.fp.lit=该 VM 不支持十六进制浮点文字

compiler.err.void.not.allowed.here=此处不允许使用 ''空'' 类型

# 0: string
compiler.err.wrong.number.type.args=类型变量数目错误; 需要{0}

# 0: symbol
compiler.err.var.might.already.be.assigned=可能已分配变量{0}

# 0: symbol
compiler.err.var.might.not.have.been.initialized=可能尚未初始化变量{0}

# 0: symbol
compiler.err.var.not.initialized.in.default.constructor=变量 {0} 未在默认构造器中初始化

# 0: symbol
compiler.err.var.might.be.assigned.in.loop=可能在 loop 中分配了变量{0}

# 0: symbol, 1: message segment
compiler.err.varargs.invalid.trustme.anno={0} 注释无效。{1}

# 0: type
compiler.misc.varargs.trustme.on.reifiable.varargs=Varargs 元素类型{0}可具体化。

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.meth=方法 {0} 不是 varargs 方法。

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs=实例方法 {0} 不是最终的。

# 0: type, 1: symbol kind, 2: symbol
compiler.misc.inaccessible.varargs.type=形式 varargs 元素类型{0}无法从 {1} {2} 进行访问

# In the following string, {1} will always be the detail message from
# java.io.IOException.
# 0: symbol, 1: string
compiler.err.class.cant.write=写入{0}时出错: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
# 0: name
compiler.err.class.public.should.be.in.file=类{0}是公共的, 应在名为 {0}.java 的文件中声明

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=笨蛋！: 

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=无法读取: {0}

#####

# Fatal Errors

compiler.misc.fatal.err.no.java.lang=杂鱼没救了呢~: 在类路径或引导类路径中找不到程序包 java.lang

compiler.misc.fatal.err.cant.locate.meth=杂鱼没救了呢~: 找不到方法{0}

compiler.misc.fatal.err.cant.locate.field=杂鱼没救了呢~: 找不到字段{0}

compiler.misc.fatal.err.cant.locate.ctor=杂鱼没救了呢~: 找不到{0}的构造器

compiler.misc.fatal.err.cant.close=杂鱼没救了呢~: 无法关闭编译器资源

#####

##
## miscellaneous strings
##

compiler.misc.source.unavailable=(源不可用)

compiler.misc.base.membership=您的所有基类都属于我们

# 0: string, 1: string, 2: boolean
compiler.misc.x.print.processor.info=处理程序{0}与{1}匹配并返回{2}。

# 0: number, 1: string, 2: set of symbol, 3: boolean
compiler.misc.x.print.rounds=循环 {0}:\n\t输入文件: {1}\n\t注释: {2}\n\t最后一个循环: {3}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".

compiler.note.compressed.diags=某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出

compiler.note.potential.lambda.found=可将此匿名内部类创建转换为 lambda 表达式。

# 0: boolean, 1: symbol
compiler.note.lambda.stat=转换 lambda 表达式\n替代 metafactory = {0}\n合成方法 = {1}

# 0: boolean, 1: unused
compiler.note.mref.stat=转换方法引用\n替代 metafactory = {0}\n
# 0: boolean, 1: symbol
compiler.note.mref.stat.1=转换方法引用\n替代 metafactory = {0}\nbridge 方法 = {1}

compiler.note.note=注: 

# 0: file name
compiler.note.deprecated.filename={0}使用或覆盖了已过时的 API。

compiler.note.deprecated.plural=某些输入文件使用或覆盖了已过时的 API。

# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=有关详细信息, 请使用 -Xlint:deprecation 重新编译。

# 0: file name
compiler.note.deprecated.filename.additional={0}还使用或覆盖了已过时的 API。

compiler.note.deprecated.plural.additional=某些输入文件还使用或覆盖了已过时的 API。

# 0: file name
compiler.note.unchecked.filename={0}使用了未经检查或不安全的操作。

compiler.note.unchecked.plural=某些输入文件使用了未经检查或不安全的操作。

# The following string may appear after one of the above deprecation
# messages.
compiler.note.unchecked.recompile=有关详细信息, 请使用 -Xlint:unchecked 重新编译。

# 0: file name
compiler.note.unchecked.filename.additional={0}还有未经检查或不安全的操作。

compiler.note.unchecked.plural.additional=某些输入文件还使用了未经检查或不安全的操作。

# 0: file name
compiler.note.sunapi.filename={0}使用了可能会在未来发行版中删除的内部专用 API。

compiler.note.sunapi.plural=某些输入文件使用了可能会在未来发行版中删除的内部专用 API。

# The following string may appear after one of the above sunapi messages.
compiler.note.sunapi.recompile=有关详细信息, 请使用 -Xlint:sunapi 重新编译。

# 0: file name
compiler.note.sunapi.filename.additional={0}使用了可能会在未来发行版中删除的其他内部专用 API。

compiler.note.sunapi.plural.additional=某些输入文件使用了可能会在未来发行版中删除的其他内部专用 API。

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
# 0: string
compiler.note.proc.messager={0}

#####

# 0: number
compiler.misc.count.error={0} 个错误

# 0: number
compiler.misc.count.error.plural={0} 个错误

# 0: number
compiler.misc.count.warn={0} 个警告

# 0: number
compiler.misc.count.warn.plural={0} 个警告

compiler.misc.version.not.available=(版本信息不可用)

## extra output when using -verbose (JavaCompiler)

# 0: symbol
compiler.misc.verbose.checking.attribution=[正在检查{0}]

# 0: string
compiler.misc.verbose.parsing.done=[解析已完成, 用时 {0} 毫秒]

# 0: file name
compiler.misc.verbose.parsing.started=[解析开始时间 {0}]

# 0: string
compiler.misc.verbose.total=[共 {0} 毫秒]

# 0: file name
compiler.misc.verbose.wrote.file=[已写入{0}]

## extra output when using -verbose (Retro)
compiler.misc.verbose.retro=[正在更新{0}]

compiler.misc.verbose.retro.with=\t正在使用{1}更新{0}

compiler.misc.verbose.retro.with.list=\t正在使用类型参数{1}, 超类型{2}和接口{3}更新{0}

## extra output when using -verbose (code/ClassReader)
# 0: string
compiler.misc.verbose.loading=[正在加载{0}]

# 0: string
compiler.misc.verbose.sourcepath=[源文件的搜索路径: {0}]

# 0: string
compiler.misc.verbose.classpath=[类文件的搜索路径: {0}]

## extra output when using -checkclassfile (code/ClassReader)
compiler.misc.ccf.found.later.version=类文件的版本高于预期: {0}

compiler.misc.ccf.unrecognized.attribute=无法识别的属性: {0}

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=继续(R), 放弃(A)>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=杂鱼~: 

## Warning messages may also include the following prefix to identify a
## lint option
# 0: option name
compiler.warn.lintOption=[{0}] 

# 0: symbol
compiler.warn.constant.SVUID=serialVersionUID 在类{0}中必须是常量

# 0: file name
compiler.warn.dir.path.element.not.found=错误的路径元素 "{0}": 没有这种目录

compiler.warn.finally.cannot.complete=finally 子句无法正常完成

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated={1}中的{0}已过时

# 0: symbol
compiler.warn.sun.proprietary={0}是内部专用 API, 可能会在未来发行版中删除

compiler.warn.illegal.char.for.encoding=编码{0}的不可映射字符，大笨蛋！

# 0: symbol
compiler.warn.improper.SVUID=必须在类{0}中将 serialVersionUID 声明为 static final

# 0: type, 1: type
compiler.warn.inexact.non-varargs.call=最后一个参数使用了不准确的变量类型的 varargs 方法的非 varargs 调用; \n对于 varargs 调用, 应使用 {0}\n对于非 varargs 调用, 应使用 {1}, 这样也可以抑制此警告

# 0: list of type
compiler.warn.unreachable.catch=catch 子句无法访问\n已捕获到抛出的类型{0}

# 0: list of type
compiler.warn.unreachable.catch.1=catch 子句无法访问\n已捕获到抛出的类型{0}

# 0: symbol
compiler.warn.long.SVUID=serialVersionUID 在类{0}中必须是 long 类型

# 0: symbol
compiler.warn.missing.SVUID=可序列化类{0}没有 serialVersionUID 的定义

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.warn.potentially.ambiguous.overload={1} 中的 {0} 可能与 {3} 中的 {2} 混淆

# 0: message segment
compiler.warn.override.varargs.missing={0}; 被覆盖的方法没有 ''...''

# 0: message segment
compiler.warn.override.varargs.extra={0}; 覆盖的方法缺少 ''...''

compiler.warn.override.bridge={0}; 被覆盖的方法为 bridge 方法

# 0: symbol
compiler.warn.pkg-info.already.seen=已找到程序包{0}的 package-info.java 文件

# 0: file name
compiler.warn.path.element.not.found=错误的路径元素 "{0}": 没有这种文件或目录

compiler.warn.possible.fall-through.into.case=可能无法实现 case

# 0: type
compiler.warn.redundant.cast=出现冗余的到{0}的转换

# 0: number
compiler.warn.position.overflow=这里 {0} 灌太满了溢出来了

# 0: file name, 1: number, 2: number
compiler.warn.big.major.version={0}: 主版本 {1} 比 {2} 新, 此编译器支持最新的主版本。\n建议升级此编译器。

# 0: symbol kind, 1: symbol
compiler.warn.static.not.qualified.by.type=static {0}应由类型名称{1}而不是表达式限定

# 0: string
compiler.warn.source.no.bootclasspath=未与 -source {0} 一起设置引导类路径

# 0: string
compiler.warn.option.obsolete.source=源值{0}已过时, 将在未来所有发行版中删除

# 0: string
compiler.warn.option.obsolete.target=目标值{0}已过时, 将在未来所有发行版中删除

compiler.warn.option.obsolete.suppression=要隐藏有关已过时选项的警告, 请使用 -Xlint:-options。

# 0: name, 1: number, 2: number, 3: number, 4: number
compiler.warn.future.attr={1}.{2} 版类文件中引入的 {0} 属性在 {3}.{4} 版类文件中被忽略

# Warnings related to annotation processing
# 0: name
compiler.warn.proc.package.does.not.exist=程序包{0}不存在

# 0: name
compiler.warn.proc.file.reopening=尝试多次为 ''{0}'' 创建文件

# 0: name
compiler.warn.proc.type.already.exists=类型 ''{0}'' 的文件已经存在于源路径或类路径中

# 0: name
compiler.warn.proc.type.recreate=尝试多次创建类型 ''{0}'' 的文件

# 0: string
compiler.warn.proc.illegal.file.name=无法创建带有非法名称 ''{0}'' 的文件。

# 0: string, 1: string
compiler.warn.proc.suspicious.class.name=正在为名称以{1}结尾的类型创建文件: ''{0}''

# 0: name
compiler.warn.proc.file.create.last.round=将不对在最后一个循环中创建的类型为 ''{0}'' 的文件进行注释处理。

# 0: string, 1: string
compiler.warn.proc.malformed.supported.string=处理程序 ''{1}'' 为支持的注释类型返回格式错误的字符串 ''{0}''

# 0: set of string
compiler.warn.proc.annotations.without.processors=没有处理程序要使用以下任何注释: {0}

# 0: source version, 1: string, 2: string
compiler.warn.proc.processor.incompatible.source.version=来自注释处理程序 ''{1}'' 的受支持 source 版本 ''{0}'' 低于 -source ''{2}''

compiler.warn.proc.proc-only.requested.no.procs=在未请求编译的情况下进行注释处理, 但找不到处理程序。

compiler.warn.proc.use.implicit=注释处理不适用于隐式编译的文件。\n使用 -implicit 指定用于隐式编译的策略。

compiler.warn.proc.use.proc.or.implicit=注释处理不适用于隐式编译的文件。\n使用 -proc:none 禁用注释处理或使用 -implicit 指定用于隐式编译的策略。

# Print a client-generated warning; assumed to be localized, no translation required
# 0: string
compiler.warn.proc.messager={0}

# 0: set of name
compiler.warn.proc.unclosed.type.files=类型 ''{0}'' 的文件未关闭; 将不针对这些类型进行注释处理

# 0: string
compiler.warn.proc.unmatched.processor.options=以下选项未被任何处理程序识别: ''{0}''

compiler.warn.try.explicit.close.call=在可自动结束的资源上显式调用 close()

# 0: symbol
compiler.warn.try.resource.not.referenced=不能在相应的 try 语句的正文中引用可自动结束的资源{0}

# 0: type
compiler.warn.try.resource.throws.interrupted.exc=可自动关闭的资源{0}包含的成员方法 close() 可能抛出 InterruptedException

compiler.warn.unchecked.assign=未经检查的分配: 将{0}分配给{1}

# 0: symbol, 1: type
compiler.warn.unchecked.assign.to.var=对作为原始类型{1}的成员的变量{0}的分配未经过检查

# 0: symbol, 1: type
compiler.warn.unchecked.call.mbr.of.raw.type=对作为原始类型{1}的成员的{0}的调用未经过检查

compiler.warn.unchecked.cast.to.type=向类型{0}的转换未经过检查

# 0: symbol kind, 1: name, 2: list of type, 3: list of type, 4: symbol kind, 5: symbol
compiler.warn.unchecked.meth.invocation.applied=方法调用未经过检查: 将{4} {5}中的{0} {1}应用到给定的类型\n需要: {2}\n找到: {3}

# 0: type
compiler.warn.unchecked.generic.array.creation=对于类型为{0}的 varargs 参数, 泛型数组创建未经过检查

# 0: type
compiler.warn.unchecked.varargs.non.reifiable.type=参数化 vararg 类型{0}的堆可能已受污染

# 0: symbol
compiler.warn.varargs.unsafe.use.varargs.param=Varargs 方法可能导致来自不可具体化 varargs 参数 {0} 的堆污染

compiler.warn.missing.deprecated.annotation=未使用 @Deprecated 对已过时的项目进行注释

compiler.warn.invalid.archive.file=以下路径中存在意外的文件: {0}

compiler.warn.unexpected.archive.file=以下档案文件存在意外的扩展名: {0}

compiler.warn.div.zero=除数就和你抽卡的出货率一样呢～

compiler.warn.empty.if=if 之后没有语句: 才一半就不行了吗(´･ω･`)?

compiler.warn.annotation.method.not.found=无法找到类型 ''{0}'' 的注释方法 ''{1}()''

compiler.warn.annotation.method.not.found.reason=无法找到类型 ''{0}'' 的注释方法 ''{1}()'': {2}

# 0: symbol, 1: name
compiler.warn.unknown.enum.constant=未知的枚举常量 {1}.{2}

# 0: symbol, 1: name, 2: message segment
compiler.warn.unknown.enum.constant.reason=未知的枚举常量 {1}.{2}\n原因: {3}

# 0: type, 1: type
compiler.warn.raw.class.use=找到原始类型: {0}\n缺少泛型类{1}的类型参数

# 0: unused, 1: unused
compiler.warn.diamond.redundant.args=新表达式中存在冗余类型参数 (改用 diamond 运算符)。

# 0: type, 1: type
compiler.warn.diamond.redundant.args.1=新表达式中存在冗余类型参数 (改用 diamond 运算符)。\n显式: {0}\n推断: {1}

# 0: symbol, 1: message segment
compiler.warn.varargs.redundant.trustme.anno=冗余的 {0} 注释。{1}

# 0: symbol
compiler.warn.access.to.sensitive.member.from.serializable.element=可串行化元素对敏感成员 {0} 的访问可以由不受信任的代码公开执行

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=<标识符>

compiler.misc.token.character=<字符>

compiler.misc.token.string=<字符串>

compiler.misc.token.integer=<整型>

compiler.misc.token.long-integer=<长整型>

compiler.misc.token.float=<浮点型>

compiler.misc.token.double=<双精度型>

compiler.misc.token.bad-symbol=<错误符号>

compiler.misc.token.end-of-input=<输入结束>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
# 0: token
compiler.err.expected=需要{0}

# 0: token, 1: token
compiler.err.expected2=需要{0}或{1}

# 0: token, 1: token, 2: token
compiler.err.expected3=需要{0}, {1}或{2}

compiler.err.premature.eof=解析时已到达文件结尾

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.dot.class.expected=需要 ''.class''

## The argument to this string will always be either 'case' or 'default'.
# 0: token
compiler.err.orphaned=孤立的{0}

# 0: name
compiler.misc.anonymous.class=<匿名{0}>

# 0: name, 1: type
compiler.misc.type.captureof=capture#{0}, 共 {1}

compiler.misc.type.captureof.1=capture#{0}

compiler.misc.type.none=<无>

compiler.misc.unnamed.package=未命名程序包

#####

# 0: symbol, 1: message segment
compiler.err.cant.access=无法访问{0}\n{1}

# 0: file name, 1: expected CP entry type, 2: constant pool index
compiler.misc.bad.const.pool.entry={0} 中错误的常量池条目\n预期为索引 {2} 处的 {1}

# 0: file name, 1: message segment
compiler.misc.bad.class.file.header=错误的类文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的类路径子目录中。

# 0: file name, 1: message segment
compiler.misc.bad.source.file.header=错误的源文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的源路径子目录中。

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=错误的类签名: {0}

#0: symbol, 1: symbol
compiler.misc.bad.enclosing.class={0}的封闭类错误: {1}

# 0: symbol
compiler.misc.bad.enclosing.method=类 {0} 的封闭方法属性错误

compiler.misc.bad.runtime.invisible.param.annotations=错误的 RuntimeInvisibleParameterAnnotations 属性: {0}

compiler.misc.bad.const.pool.tag=错误的常量池标记: {0}

compiler.misc.bad.const.pool.tag.at=错误的常量池标记: {0}, 位于{1}

compiler.misc.bad.signature=错误的签名: {0}

compiler.misc.bad.type.annotation.value=错误的类型注释目标类型值: {0}

compiler.misc.class.file.wrong.class=类文件包含错误的类: {0}

compiler.misc.class.file.not.found=找不到{0}的类文件

# 0: classfile major version, 1: classfile minor version
compiler.misc.invalid.default.interface=在 {0}.{1} 版类文件中找到默认方法

# 0: classfile major version, 1: classfile minor version
compiler.misc.invalid.static.interface=在 {0}.{1} 版类文件中找到静态方法

# 0: name
compiler.misc.file.doesnt.contain.class=文件不包含类{0}

compiler.misc.file.does.not.contain.package=文件不包含程序包{0}

compiler.misc.illegal.start.of.class.file=非法的类文件开始

compiler.misc.unable.to.access.file=无法访问文件: {0}

compiler.misc.unicode.str.not.supported=不支持类文件中的 Unicode 字符串

compiler.misc.undecl.type.var=未声明的类型变量: {0}

compiler.misc.wrong.version=类文件具有错误的版本 {0}.{1}, 应为 {2}.{3}

#####

# 0: type, 1: type or symbol
compiler.err.not.within.bounds=类型参数{0}不在类型变量{1}的范围内

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

# 0: message segment
compiler.err.prob.found.req=这里？: {0}

# 0: message segment
compiler.misc.prob.found.req=这里？: {0}

# 0: message segment, 1: type, 2: type
compiler.warn.prob.found.req={0}\n需要: {2}\n找到:    {1}

# 0: type, 1: type
compiler.misc.inconvertible.types={0}这里变不了哦！{1}

# 0: type, 1: type
compiler.misc.possible.loss.of.precision=从{0}转换到{1}可能会有损失

compiler.misc.unchecked.assign=不深入的查查看吗？

# compiler.misc.storecheck=\
#     assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=不深入的查查看吗？

# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

# 0: type
compiler.misc.try.not.applicable.to.type=try-with-resources 不适用于变量类型\n({0})

#####

# 0: message segment or type, 1: message segment
compiler.err.type.found.req=意外的类型\n需要: {1}\n找到:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=类

compiler.misc.type.req.class.array=类或数组

compiler.misc.type.req.array.or.iterable=数组或 java.lang.Iterable

compiler.misc.type.req.ref=引用

compiler.misc.type.req.exact=不带限制范围的类或接口

# 0: type
compiler.misc.type.parameter=类型参数{0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"

# 0: type, 1: list of type
compiler.misc.no.unique.maximal.instance.exists=对于上限为{1}的类型变量{0}, 不存在唯一最大实例

compiler.misc.no.unique.minimal.instance.exists=对于下限为{1}的类型变量{0}, 不存在唯一最小实例

# 0: type, 1: list of type
compiler.misc.incompatible.upper.bounds=推论变量 {0} 具有不兼容的上限 {1}

# 0: type, 1: list of type, 2: list of type
compiler.misc.incompatible.eq.upper.bounds=推论变量 {0} 具有不兼容的限制范围\n等式约束条件: {1}\n上限: {2}

# 0: type, 1: list of type, 2: list of type
compiler.misc.incompatible.eq.lower.bounds=推论变量{0}具有不兼容的限制范围\n等式约束条件: {1}\n下限: {2}

# 0: list of type, 1: type, 2: type
compiler.misc.infer.no.conforming.instance.exists=不存在类型变量{0}的实例, 以使{1}与{2}一致

# 0: list of type, 1: message segment
compiler.misc.infer.no.conforming.assignment.exists=无法推断类型变量 {0}\n(参数不匹配; {1})

# 0: list of type
compiler.misc.infer.arg.length.mismatch=无法推断类型变量 {0}\n(实际参数列表和形式参数列表长度不同)

# 0: list of type, 1: message segment
compiler.misc.infer.varargs.argument.mismatch=无法推断类型变量 {0}\n(varargs 不匹配; {1})

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.upper.bounds=推断类型不符合上限\n推断: {0}\n上限: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.lower.bounds=推断类型不符合下限\n推断: {0}\n下限: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.eq.bounds=推断类型不符合等式约束条件\n推断: {0}\n等式约束条件: {1}

# 0: symbol
compiler.misc.diamond={0}<>

# 0: type
compiler.misc.diamond.non.generic=无法将 ''<>'' 与非泛型类{0}一起使用

# 0: unused
compiler.misc.diamond.and.explicit.params=不可以哦！ ''<>'' 与构造器的显式类型参数一起使用

# 0: unused
compiler.misc.mref.infer.and.explicit.params=不可以哦！原始构造器引用与构造器的显式类型参数一起使用

# 0: type, 1: list of type
compiler.misc.explicit.param.do.not.conform.to.bounds=显式类型参数{0}不符合声明的范围{1}

compiler.misc.arg.length.mismatch=实际参数列表和形式参数列表长度不同

# 0: message segment
compiler.misc.no.conforming.assignment.exists=参数不匹配; {0}

# 0: message segment
compiler.misc.varargs.argument.mismatch=varargs 不匹配; {0}

#####

# 0: symbol or type, 1: file name
compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file={1} 中的辅助类{0}不应从其自身的源文件以外访问

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol, 2: symbol
compiler.err.abstract.cant.be.accessed.directly=无法直接访问{2}中的抽象{0} {1}

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.non-static.cant.be.ref=无法从静态上下文中引用非静态 {0} {1}

# 0: symbol kind, 1: symbol
compiler.misc.non-static.cant.be.ref=无法从静态上下文中引用非静态 {0} {1}

# 0: symbol kind, 1: symbol
compiler.misc.static.method.in.unbound.lookup=在未绑定查找中找到静态{0} {1}

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
compiler.err.unexpected.type=意外的类型\n需要: {0}\n找到:    {1}

compiler.err.unexpected.lambda=此处不应为 lambda 表达式

compiler.err.unexpected.mref=此处不应为方法引用

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
# 0: symbol kind, 1: name, 2: unused, 3: unused
compiler.err.cant.resolve=咦？居然连符号都找不到了呀~ 杂鱼~\n符号: {0} {1}

# 0: symbol kind, 1: name, 2: unused, 3: list of type
compiler.err.cant.resolve.args=咦？居然连符号都找不到了呀~ 杂鱼~\n符号: {0} {1}({3})

# 0: symbol kind, 1: name, 2: list of type, 3: list of type
compiler.err.cant.resolve.args.params=咦？居然连符号都找不到了呀~ 杂鱼~\n符号: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is a location subdiagnostic (see below)
# 0: symbol kind, 1: name, 2: unused, 3: unused, 4: message segment
compiler.err.cant.resolve.location=咦？居然连符号都找不到了呀~ 杂鱼~\n符号:   {0} {1}\n位置: {4}

# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.err.cant.resolve.location.args=咦？居然连符号都找不到了呀~ 杂鱼~\n符号:   {0} {1}({3})\n位置: {4}

# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
compiler.err.cant.resolve.location.args.params=咦？居然连符号都找不到了呀~ 杂鱼~\n符号:   {0} <{2}>{1}({3})\n位置: {4}

### Following are replicated/used for method reference diagnostics

# 0: symbol kind, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.misc.cant.resolve.location.args=咦？居然连符号都找不到了呀~ 杂鱼~\n符号:   {0} {1}({3})\n位置: {4}

# 0: symbol kind, 1: name, 2: list of type, 3: list, 4: message segment
compiler.misc.cant.resolve.location.args.params=咦？居然连符号都找不到了呀~ 杂鱼~\n符号:   {0} <{2}>{1}({3})\n位置: {4}

##a location subdiagnostic is composed as follows:
## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the location name
## The third argument {2} is the location type (only when {1} is a variable name)

# 0: symbol kind, 1: type or symbol, 2: unused
compiler.misc.location={0} {1}

# 0: symbol kind, 1: symbol, 2: type
compiler.misc.location.1=类型为{2}的{0} {1}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=@interface

compiler.misc.kindname.constructor=构造器

compiler.misc.kindname.enum=枚举

compiler.misc.kindname.interface=接口

compiler.misc.kindname.static=静态

compiler.misc.kindname.type.variable=类型变量

compiler.misc.kindname.type.variable.bound=类型变量的限制范围

compiler.misc.kindname.variable=变量

compiler.misc.kindname.value=值

compiler.misc.kindname.method=方法

compiler.misc.kindname.class=类

compiler.misc.kindname.package=程序包

compiler.misc.kindname.static.init=静态初始化程序

compiler.misc.kindname.instance.init=实例初始化程序

#####

compiler.misc.no.args=没有参数

# 0: message segment
compiler.err.override.static={0}\n覆盖的方法为 static

# 0: message segment, 1: set of modifier
compiler.err.override.meth={0}\n被覆盖的方法为{1}

# 0: message segment, 1: type
compiler.err.override.meth.doesnt.throw={0}\n被覆盖的方法未抛出{1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
# 0: message segment, 1: set of modifier
compiler.err.override.weaker.access={0}\n正在尝试分配更低的访问权限; 以前为{1}

# 0: message segment, 1: type, 2: type
compiler.err.override.incompatible.ret={0}\n返回类型{1}与{2}不兼容

# 0: message segment, 1: type, 2: type
compiler.warn.override.unchecked.ret={0}\n返回类型需要从{1}到{2}的不深入的查查看吗？

# 0: message segment, 1: type
compiler.warn.override.unchecked.thrown={0}\n被覆盖的方法未抛出{1}

# 0: symbol
compiler.warn.override.equals.but.not.hashcode=类{0}覆盖了 equals, 但该类或任何超类都未覆盖 hashCode 方法

## The following are all possible strings for the first argument ({0}) of the
## above strings.
# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.override={1}中的{0}无法覆盖{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.implement={1}中的{0}无法实现{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.clashes.with={1}中的{0}与{3}中的{2}冲突

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.override={1}中的{0}覆盖了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.implement={1}中的{0}实现了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.clash.with={1}中的{0}覆盖了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.override={1}中的{0}覆盖了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.implement={1}中的{0}实现了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.clash.with={1}中的{0}覆盖了{3}中的{2}

# 0: unused
compiler.misc.diamond.and.anon.class=无法将 ''<>'' 与匿名内部类一起使用

# 0: symbol kind, 1: symbol, 2: symbol, 3: message segment
compiler.misc.inapplicable.method={0} {1}.{2}不适用\n({3})

########################################
# Diagnostics for language feature changes
########################################
# 0: string
compiler.err.unsupported.fp.lit=-source {0} 中不支持十六进制浮点文字\n(请使用 -source 5 或更高版本以启用十六进制浮点文字)

# 0: string
compiler.err.unsupported.binary.lit=-source {0} 中不支持二进制文字\n(请使用 -source 7 或更高版本以启用二进制文字)

# 0: string
compiler.err.unsupported.underscore.lit=-source {0} 中不支持文字中存在下划线\n(请使用 -source 7 或更高版本以允许文字中存在下划线)

# 0: string
compiler.err.try.with.resources.not.supported.in.source=-source {0} 中不支持 try-with-resources\n(请使用 -source 7 或更高版本以启用 try-with-resources)

compiler.warn.enum.as.identifier=从发行版 5 开始, ''enum'' 为关键字, 而不用作标识符\n(请使用 -source 5 或更高版本以将 ''enum'' 用作关键字)

compiler.warn.assert.as.identifier=从发行版 1.4 开始, ''assert'' 是一个关键字, 但不能用作标识符\n(请使用 -source 1.4 或更高版本以将 ''assert'' 用作关键字)

compiler.warn.underscore.as.identifier=''_'' 用作标识符\n(Java SE 8 之后的发行版中可能不支持使用 ''_'' 作为标识符)

compiler.err.underscore.as.identifier.in.lambda=''_'' 用作标识符\n(对于 lambda 参数, 禁止将 ''_'' 用作标识符)

compiler.err.enum.as.identifier=从发行版 5 开始, ''enum'' 为关键字, 而不用作标识符\n(请使用 -source 1.4 或更低版本以将 ''enum'' 用作标识符)

compiler.err.assert.as.identifier=从发行版 1.4 开始, ''assert'' 是一个关键字, 但不能用作标识符\n(请使用 -source 1.3 或更低版本以将 ''assert'' 用作标识符)

# TODO 308: make a better error message
compiler.err.this.as.identifier=从发行版 8 开始, ''this'' 只能作为接收方类型的参数名, 该参数必须为第一个参数

# 0: symbol
compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=接收方参数不适用于顶层类的构造器

# TODO 308: make a better error message
# 0: symbol
compiler.err.cant.type.annotate.scoping.1=无法使用 type-use 注释 {0} 来注释确定作用域结构

# TODO 308: make a better error message
# 0: list of symbol
compiler.err.cant.type.annotate.scoping=无法使用 type-use 注释 {0} 来注释确定作用域结构

# 0: type, 1: type
compiler.err.incorrect.receiver.name=接收方名称与封闭类类型不匹配\n需要: {0}\n找到: {1}

# 0: type, 1: type
compiler.err.incorrect.receiver.type=接收方类型与封闭类类型不匹配\n需要: {0}\n找到: {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.type=接收方类型与外部封闭类类型不匹配\n需要: {0}\n找到: {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.name=接收方名称与外部封闭类类型不匹配\n需要: {0}\n找到: {1}

compiler.err.no.annotations.on.dot.class=类文字类型中不允许使用任何注释

# 0: string
compiler.err.generics.not.supported.in.source=-source {0} 中不支持泛型\n(请使用 -source 5 或更高版本以启用泛型)

# 0: string
compiler.err.varargs.not.supported.in.source=-source {0} 中不支持 variable-arity 方法\n(请使用 -source 5 或更高版本以启用 variable-arity 方法)

# 0: string
compiler.err.annotations.not.supported.in.source=-source {0} 中不支持注释\n(请使用 -source 5 或更高版本以启用注释)

# 0: string
compiler.err.type.annotations.not.supported.in.source=-source {0} 中不支持类型注释\n(请使用 -source 8 或更高版本以启用类型注释)

# 0: string
compiler.err.annotations.after.type.params.not.supported.in.source=-source {0} 中不支持方法类型参数后的注释\n(请使用 -source 8 或更高版本以启用方法类型参数后的注释)

# 0: string
compiler.err.repeatable.annotations.not.supported.in.source=-source {0}中不支持重复注释\n(请使用 -source 8 或更高版本以启用重复注释)

# 0: string
compiler.err.foreach.not.supported.in.source=-source {0}中不支持增强型 for 循环\n(使用 -source 5 或更高版本以启用 for-each 循环)

# 0: string
compiler.err.static.import.not.supported.in.source=-source {0} 中不支持静态导入声明\n(请使用 -source 5 或更高版本以启用静态导入声明)

# 0: string
compiler.err.enums.not.supported.in.source=-source {0} 中不支持枚举\n(请使用 -source 5 或更高版本以启用枚举)

# 0: string
compiler.err.diamond.not.supported.in.source=-source {0} 中不支持 diamond 运算符\n(请使用 -source 7 或更高版本以启用 diamond 运算符)

# 0: string
compiler.err.multicatch.not.supported.in.source=-source {0} 中不支持 multi-catch 语句\n(请使用 -source 7 或更高版本以启用 multi-catch 语句)

# 0: string
compiler.err.string.switch.not.supported.in.source=-source {0} 中不支持 switch 中存在字符串\n(请使用 -source 7 或更高版本以允许 switch 中存在字符串)

# 0: string
compiler.err.lambda.not.supported.in.source=-source {0} 中不支持 lambda 表达式\n(请使用 -source 8 或更高版本以启用 lambda 表达式)

# 0: string
compiler.err.method.references.not.supported.in.source=-source {0} 中不支持方法引用\n(请使用 -source 8 或更高版本以启用方法引用)

# 0: string
compiler.err.default.methods.not.supported.in.source=-source {0} 中不支持默认方法\n(请使用 -source 8 或更高版本以启用默认方法)

# 0: string
compiler.err.intersection.types.in.cast.not.supported.in.source=-source {0} 中不支持转换中的交叉类型\n(请使用 -source 8 或更高版本以启用默认方法)

# 0: string
compiler.err.static.intf.methods.not.supported.in.source=-source {0} 中不支持静态接口方法\n(请使用 -source 8 或更高版本以启用静态接口方法)

# 0: string
compiler.err.static.intf.method.invoke.not.supported.in.source=-source {0} 中不支持静态接口方法调用\n(请使用 -source 8 或更高版本以启用静态接口方法调用)

########################################
# Diagnostics for verbose resolution
# used by Resolve (debug only)
########################################

# 0: number, 1: symbol, 2: unused
compiler.misc.applicable.method.found=找到第 {0} 个适用方法: {1}

# 0: number, 1: symbol, 2: message segment
compiler.misc.applicable.method.found.1=找到第 {0} 个适用方法: {1}\n({2})

# 0: number, 1: symbol, 2: message segment
compiler.misc.not.applicable.method.found=找到第 {0} 个不适用的方法: {1}\n({2})

# 0: type
compiler.misc.partial.inst.sig=部分实例化为: {0}

# 0: name, 1: symbol, 2: number, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi=将类型 {1} 的方法 {0} 解析为候选项 {2}\n阶段: {3}\n具有实际值: {4}\n具有类型参数: {5}\n候选项:

# 0: name, 1: symbol, 2: unused, 3: MethodResolutionPhase, 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi.1=类型 {1} 的方法 {0} 解析错误\n阶段: {3}\n具有实际值: {4}\n具有类型参数: {5}\n候选项:

# 0: symbol, 1: type, 2: type
compiler.note.deferred.method.inst=方法 {0} 的延迟实例化\n实例化签名: {1}\n目标类型: {2}

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=<空值>

# X#n (where n is an int id) is disambiguated tvar name
# 0: name, 1: number
compiler.misc.type.var={0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
# 0: number
compiler.misc.captured.type=CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
# 0: number
compiler.misc.intersection.type=INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: type, 3: type
compiler.misc.where.captured={0}从{3}的捕获扩展{1} 超 {2}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: unused, 3: type
compiler.misc.where.captured.1={0}从{3}的捕获扩展{1}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar={0}扩展已在{2} {3}中声明的{1}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar.1={0}已在{2} {3}中声明

# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
# Since a fresh type-variable is synthetic - there's no location/kindname here.
# 0: type, 1: list of type
compiler.misc.where.fresh.typevar={0}扩展{1}

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
# 0: type, 1: list of type
compiler.misc.where.intersection={0}扩展{1}

### Where clause headers ###
compiler.misc.where.description.captured=其中, {0}是新类型变量:

# 0: set of type
compiler.misc.where.description.typevar=其中, {0}是类型变量:

# 0: set of type
compiler.misc.where.description.intersection=其中, {0}是交叉类型:

# 0: set of type
compiler.misc.where.description.captured.1=其中, {0}是新类型变量:

# 0: set of type
compiler.misc.where.description.typevar.1=其中, {0}是类型变量:

compiler.misc.where.description.intersection.1=其中, {0}是交叉类型:

###
# errors related to doc comments

compiler.err.dc.bad.entity=HTML 实体错误

compiler.err.dc.bad.gt=''>'' 的用法错误

compiler.err.dc.bad.inline.tag=内嵌标记的用法不正确

compiler.err.dc.identifier.expected=需要标识符

compiler.err.dc.malformed.html=格式错误的 HTML

compiler.err.dc.missing.semicolon=缺少分号

compiler.err.dc.no.content=无内容

compiler.err.dc.no.tag.name='@' 后没有标记名

compiler.err.dc.gt.expected=需要 ''>''

compiler.err.dc.ref.bad.parens=引用中缺少 '')''

compiler.err.dc.ref.syntax.error=引用中出现语法错误

compiler.err.dc.ref.unexpected.input=意外的文本

compiler.err.dc.unexpected.content=意外的内容

compiler.err.dc.unterminated.inline.tag=未终止的内嵌标记

compiler.err.dc.unterminated.signature=未终止的签名

compiler.err.dc.unterminated.string=未终止的字符串


